class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n=graph.size();
        vector<vector<int>> adj(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i==j)
                    continue;
                if(graph[i][j]==1){
                    adj[i].push_back(j);
                }
            }
        }

        // for(int i=0;i<n;i++){
        //     cout<<i<<" -> ";
        //     for(int j=0;j<adj[i].size();j++){
        //         cout<<adj[i][j]<<" ,";
        //     }
        //     cout<<endl;
        // }
        int componentNo=0;
        unordered_map<int,pair<int,int>> numCount;
        int maxInitial=INT_MIN;
        for(auto i:initial){
            maxInitial=max(i,maxInitial);
        }
        unordered_set<int> init(initial.begin(),initial.end());
        unordered_map<int,int> initComp;
        vector<int> visited(n);
        for(int i=0;i<n;i++){
            if(visited[i]!=1){
                int componentsCount=0;
                int initCount=0;
                dfs(adj,i,initComp,init,visited,componentsCount,initCount,componentNo);
                numCount[componentNo]={componentsCount,initCount};
                // cout<<componentNo<<" -> "<<componentsCount<<" , "<<initCount<<endl;
                componentNo++;
            }
        }
        // cout<<"initiComp"<<endl;
        // for(auto [a,b]:initComp){
        //     cout<<a<<" -> "<<b<<endl;
        // }
        sort(initial.begin(),initial.end());
        int safe=INT_MIN;
        int ans=initial[0];
        for(int i=0;i<initial.size();i++){
            int compBelong=initComp[initial[i]];
            if(numCount[compBelong].second==1){
                if(numCount[compBelong].first>safe){
                    safe=numCount[compBelong].first;
                    ans=initial[i];
                }
            }
        }
        return ans;
    }

    void dfs(vector<vector<int>>& adj,int node,unordered_map<int,int>& initComp,unordered_set<int>& init,vector<int>& visited,int& componentsCount,int& initCount,int& componentNo){
        
        visited[node]=1;
        if(init.find(node)!=init.end()){
            initCount++;
            initComp[node]=componentNo;
        }
        componentsCount++;
        for(auto &n:adj[node]){
            if(visited[n]!=1){
                dfs(adj,n,initComp,init,visited,componentsCount,initCount,componentNo);
            }
        }
        return;
    }
};